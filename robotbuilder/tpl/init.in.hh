@LICENSE@
// This file has been generated by the metapod robotbuilder library.

#ifndef @LIBRARY_NAME@_INIT_HH
# define @LIBRARY_NAME@_INIT_HH

# ifdef _MSC_VER
#  pragma warning( push )
// disable warning C4251: need to have DLL interface
// disable warning C4099: struct/class discrepancies
// The following warnings are only needed if the FloatType is float, because
// the code generator uses double anyway.
// disable warning C4305 truncation from 'double' to 'float'
// disable warning C4244 conversion from 'double' to 'float', possible loss of data
#  pragma warning( disable: 4251 4099 4305 4244 )
# endif

// The sparse module API is not stable yet.
# define EIGEN_YES_I_KNOW_SPARSE_MODULE_IS_NOT_STABLE_YET

# include "config.hh"

# include <metapod/tools/common.hh>
# include <metapod/tools/joint.hh>
# include <metapod/tools/initnufwddyn.hh>
# include <metapod/tools/qcalc.hh>
# include <Eigen/Sparse>

// by default, boost fusion vector only provides constructor for vectors with
// up to 10 elements.
# if !defined(FUSION_MAX_VECTOR_SIZE) && (@ROBOT_NB_BODIES@ > 10)
#  define FUSION_MAX_VECTOR_SIZE @ROBOT_NB_BODIES@
# endif
# if defined(FUSION_MAX_VECTOR_SIZE) && (@ROBOT_NB_BODIES@ > FUSION_MAX_VECTOR_SIZE)
// todo: warn or stop
# endif
# include <boost/fusion/sequence.hpp>
# include <boost/fusion/include/sequence.hpp>
# include <boost/fusion/include/vector.hpp>
# include <metapod/algos/crba.hh>
# include <metapod/algos/hcrba.hh>
//# include <metapod/tools/sparseHfromTrackNZs.hh>

namespace metapod {

template <typename FloatType>
class @LIBRARY_NAME@_DLLAPI @ROBOT_CLASS_NAME@ {
  METAPOD_TYPEDEFS;
public:
  // the following new/delete operators are only needed if there is a
  // member variable of fixed-size vectorizable Eigen type (or a member
  // having such a member).
  // It's not easy to tell in advance, so let always use the aligned operators.
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  // Global constants or variable of the robot
  enum { NBDOF = @ROBOT_NB_DOF@ };
  enum { NBBODIES = @ROBOT_NB_BODIES@ };

  typedef FloatType RobotFloatType;
  typedef Eigen::Matrix< FloatType, NBDOF, 1 > confVector;

  enum NodeId
  {
@nodeid_enum_definition@
  };

  // children of the root/NP node
  static const int child0_id = @root_child0_id@;
  static const int child1_id = @root_child1_id@;
  static const int child2_id = @root_child2_id@;
  static const int child3_id = @root_child3_id@;
  static const int child4_id = @root_child4_id@;

  // definition of the node classes (except the root/NP node)
@node_type_definitions@

  // vector of the robot nodes
  typedef boost::fusion::vector@ROBOT_NB_BODIES@<
@nodes_type_list@>
  NodeVector;

  // member variables

  // inertias expressed in body frames
  static Inertia inertias[@ROBOT_NB_BODIES@];
  NodeVector nodes;
  Eigen::Matrix< FloatType, NBDOF, NBDOF > H; // used by crba, hcrba and chda
  Eigen::SparseMatrix< FloatType > sparseH; // sparse matrix for solving unknown accelerations
                                            // (hybrid dynamics algorithm).
  typedef Eigen::Triplet<FloatType> Tripletf;
  std::vector<Tripletf> sparseHtripletList;

  // permutation matrix Q
  typedef Eigen::Matrix<FloatType, 1, NBDOF> VectorNBDOFf;
  typedef Eigen::Matrix<FloatType, NBDOF, NBDOF> MatrixNBDOFf;
  typedef Eigen::PermutationMatrix<NBDOF, NBDOF, FloatType> PermutationMatrixNBDOFf;

  static const int nbFdDOF = @fwdDyn_joints_dof@;
  static VectorNBDOFf fdNodesFirst; // permutation indexes for building Q matrix
  static VectorNBDOFf idNodes; // permutation indexes for building Q matrix
  static int fdNodesFirstFillIndex;
  static int idNodesFillIndex;
  static PermutationMatrixNBDOFf Q;
  static PermutationMatrixNBDOFf Qt; // transpose of Q
  
  @ROBOT_CLASS_NAME@():
    H(MatrixNBDOFf::Zero()),
    sparseH(NBDOF,NBDOF)
  {
    // we shall use permutation matrix Q within the hybrid dynamics algorithm
    qcalc< @ROBOT_CLASS_NAME@ >::run(); // Apply the permutation matrix Q
    sparseHtripletList.reserve(NBDOF*NBDOF);
    crba< @ROBOT_CLASS_NAME@, false, true >::run(*this); // Run CRBA for tracking Non-Zero coefficients
    //initSparseHfromTrackNZs< >(*this);
    sparseH.setFromTriplets(sparseHtripletList.begin(), sparseHtripletList.end());
    sparseH.makeCompressed();
    std::cout << sparseH << std::endl << std::endl;
    std::cout << H << std::endl << std::endl;
  }
};

// map node id to node type
@map_node_id_to_type@

} // closing namespace metapod

# ifdef _MSC_VER
#  pragma warning( pop )
# endif

#endif
