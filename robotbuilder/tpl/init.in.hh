@LICENSE@
// This file has been generated by the metapod robotbuilder library.

#ifndef @LIBRARY_NAME@_INIT_HH
# define @LIBRARY_NAME@_INIT_HH

# ifdef _MSC_VER
#  pragma warning( push )
// disable warning C4251: need to have DLL interface
// disable warning C4099: struct/class discrepancies
// The following warnings are only needed if the FloatType is float, because
// the code generator uses double anyway.
// disable warning C4305 truncation from 'double' to 'float'
// disable warning C4244 conversion from 'double' to 'float', possible loss of data
#  pragma warning( disable: 4251 4099 4305 4244 )
# endif

// The sparse module API is not stable yet.
# define EIGEN_YES_I_KNOW_SPARSE_MODULE_IS_NOT_STABLE_YET

# include "config.hh"

# include <metapod/tools/common.hh>
# include <metapod/tools/joint.hh>
# include <metapod/tools/initnufwddyn.hh>
# include <metapod/tools/qcalc.hh>
# include <Eigen/Sparse>
# include <Eigen/OrderingMethods>

// by default, boost fusion vector only provides constructor for vectors with
// up to 10 elements.
# if !defined(FUSION_MAX_VECTOR_SIZE) && (@ROBOT_NB_BODIES@ > 10)
#  define FUSION_MAX_VECTOR_SIZE @ROBOT_NB_BODIES@
# endif
# if defined(FUSION_MAX_VECTOR_SIZE) && (@ROBOT_NB_BODIES@ > FUSION_MAX_VECTOR_SIZE)
// todo: warn or stop
# endif
# include <boost/fusion/sequence.hpp>
# include <boost/fusion/include/sequence.hpp>
# include <boost/fusion/include/vector.hpp>
# include <metapod/algos/crba.hh>
# include <metapod/algos/hcrba.hh>
//# include <metapod/tools/sparseHfromTrackNZs.hh>

namespace metapod {

template <typename FloatType>
class @LIBRARY_NAME@_DLLAPI @ROBOT_CLASS_NAME@ {
  METAPOD_TYPEDEFS;
public:
  // the following new/delete operators are only needed if there is a
  // member variable of fixed-size vectorizable Eigen type (or a member
  // having such a member).
  // It's not easy to tell in advance, so let always use the aligned operators.
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  // Global constants or variable of the robot
  enum { NBDOF = @ROBOT_NB_DOF@ };
  enum { NBBODIES = @ROBOT_NB_BODIES@ };

  typedef FloatType RobotFloatType;
  typedef Eigen::Matrix< FloatType, NBDOF, 1 > confVector;

  enum NodeId
  {
@nodeid_enum_definition@
  };

  // children of the root/NP node
  static const int child0_id = @root_child0_id@;
  static const int child1_id = @root_child1_id@;
  static const int child2_id = @root_child2_id@;
  static const int child3_id = @root_child3_id@;
  static const int child4_id = @root_child4_id@;

  // definition of the node classes (except the root/NP node)
@node_type_definitions@

  // vector of the robot nodes
  typedef boost::fusion::vector@ROBOT_NB_BODIES@<
@nodes_type_list@>
  NodeVector;

  // member variables
  typedef Eigen::Matrix< int, 1, NBDOF > VectorNBDOFi;
  typedef Eigen::Matrix< FloatType, NBDOF, NBDOF > MatrixNBDOFf;
  typedef Eigen::PermutationMatrix< NBDOF, NBDOF, int > PermutationMatrixNBDOFi;
  typedef Eigen::Triplet< FloatType > Tripletf;
  typedef Eigen::SparseMatrix< FloatType  > SparseMatrixf;

  // inertias expressed in body frames
  static Inertia inertias[@ROBOT_NB_BODIES@];
  NodeVector nodes;
  MatrixNBDOFf H; // used by crba, hcrba and chda
  SparseMatrixf sparseH11; // sparse matrix for solving unknown accelerations
                           // (hybrid dynamics algorithm).
  std::vector<Tripletf> sparseHtripletList;
  Eigen::SimplicialLLT<SparseMatrixf> lltOfH11;
  Eigen::PermutationMatrix<Eigen::Dynamic, Eigen::Dynamic, int> perm;

  // permutation matrix Q
  static const int nbFdDOF = @fwdDyn_joints_dof@;
  typedef Eigen::Matrix<FloatType, nbFdDOF, nbFdDOF> MatrixDof11;
  static VectorNBDOFi fdNodesFirst; // permutation indexes for building Q matrix
  static VectorNBDOFi idNodes; // permutation indexes for building Q matrix
  static int fdNodesFirstFillIndex;
  static int idNodesFillIndex;
  static PermutationMatrixNBDOFi Q;
  static PermutationMatrixNBDOFi Qt; // transpose of Q

  @ROBOT_CLASS_NAME@():
    H(MatrixNBDOFf::Zero()),
    sparseH11(nbFdDOF,nbFdDOF)
  {
    // we shall use permutation matrix Q within the hybrid dynamics algorithm
    qcalc< @ROBOT_CLASS_NAME@ >::run(); // Apply the permutation matrix Q
    sparseHtripletList.reserve(NBDOF*NBDOF);
    crba< @ROBOT_CLASS_NAME@, false, true >::run(*this); // Run CRBA for tracking Non-Zero coefficients
    //initSparseHfromTrackNZs< >(*this);
    SparseMatrixf sparseH(NBDOF, NBDOF);
    sparseH.setFromTriplets(sparseHtripletList.begin(), sparseHtripletList.end()); // generate the sparseH from the list of non-zero coefficients
    sparseH.makeCompressed(); // remove empty slots

    // reorder sparseH as per permutation matrix Q, and extract sparse H11
    SparseMatrixf sparseHrff(NBDOF, NBDOF);
    sparseHrff = Q * SparseMatrixf(sparseH * Qt); // sparseH reordered
    sparseH11 = sparseHrff.topLeftCorner(nbFdDOF, nbFdDOF); // H11, square sub-matrix of size "nbFdDOF x nbFdDOF"
    std::cout << "sparseH :\n" << sparseH << std::endl;
    std::cout << "sparseHrff :\n" << sparseHrff << std::endl;
    std::cout << "sparseH11 :\n" << sparseH11 << std::endl;
    std::cout << "perm Q and Qt :\n" << Q.toDenseMatrix() << "\n\n" << std::endl;

    Eigen::COLAMDOrdering<int> ordering;
    //ordering.operator()< SparseMatrixf, Eigen::Lower >(sparseH11.template selfadjointView<Eigen::Lower>(), perm)
    ordering.operator()< SparseMatrixf >(sparseH11, perm); // Call COLAMD: computes permutation vector perm.
    std::cout << perm.toDenseMatrix();

    // reorder the nonzero elements of the matrix, such that the factorization step creates less fill-in.
    // This step exploits only the structure of the matrix.
    //lltOfH11.analyzePattern(perm * SparseMatrixf(sparseH11 * perm.transpose()));
    lltOfH11.analyzePattern(sparseH11);
  }
};

// map node id to node type
@map_node_id_to_type@

} // closing namespace metapod

# ifdef _MSC_VER
#  pragma warning( pop )
# endif

#endif
